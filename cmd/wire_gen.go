// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/rhbarauna/goexpert-desafio-rate-limiter/configs"
	"github.com/rhbarauna/goexpert-desafio-rate-limiter/internal/limiter"
	"github.com/rhbarauna/goexpert-desafio-rate-limiter/internal/middleware"
	"github.com/rhbarauna/goexpert-desafio-rate-limiter/internal/storage"
	"github.com/rhbarauna/goexpert-desafio-rate-limiter/internal/storage/redis"
	"path/filepath"
	"runtime"
)

// Injectors from wire.go:

func NewRateLimiter() (middleware.RateLimiter, error) {
	config := provideConfig()
	storage := provideStorage(config)
	limiterInterface := provideLimiter(storage, config)
	rateLimiter := provideRateLimiter(limiterInterface)
	return rateLimiter, nil
}

// wire.go:

func provideConfig() *configs.Config {
	_, currentFile, _, ok := runtime.Caller(0)
	if !ok {
		panic("Erro ao obter informações do arquivo.")
	}
	goDir := filepath.Dir(currentFile)

	config, err := configs.LoadConfig(goDir)
	if err != nil {
		panic(err)
	}
	return config
}

func provideStorage(config *configs.Config) storage.Storage {
	return redis.NewRedisStorage(config.DBUser, config.DBPassword, config.DBHost, config.DBPort, config.DBName)
}

func provideLimiter(storage2 storage.Storage, config *configs.Config) limiter.LimiterInterface {
	return limiter.NewLimiter(storage2, config.Cooldown, config.MaxRequests, config.Ttl, config.Tokens)
}

func provideRateLimiter(limiter2 limiter.LimiterInterface) middleware.RateLimiter {
	return middleware.NewRateLimiter(limiter2)
}

func GetWebServerPort() string {
	return provideConfig().WebServerPort
}
